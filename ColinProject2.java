/* Project 2Per email, we are NOT supposed to ask the user to input dataPrepared for Prof. Shantaram VasikarlaStarting with an empty tree, perform the following insertion operations:insert(58)insert(70)insert(46)insert(48)insert(96)insert(98)insert(22)insert(24)insert(10)insert(63)insert(68)insert(94)insert(44)insert(87)insert(84)And then do the following deletions:delete(96)delete(68)delete(44)delete(87)delete(84)delete(22)*///Node Classclass Nod {  int item, hei;  Nod lef, ri;  Nod(int d) {    item = d;    hei = 1;  }}class ColinProject2 {  public static void main(String[] args) {    ColinProject2 tree = new ColinProject2();    System.out.println("AVL tree(before deletion): ");    tree.root = tree.insertNod(tree.root, 58);    tree.root = tree.insertNod(tree.root, 70);    tree.root = tree.insertNod(tree.root, 46);    tree.root = tree.insertNod(tree.root, 48);    tree.root = tree.insertNod(tree.root, 96);    tree.root = tree.insertNod(tree.root, 98);    tree.root = tree.insertNod(tree.root, 22);    tree.root = tree.insertNod(tree.root, 24);    tree.root = tree.insertNod(tree.root, 10);    tree.root = tree.insertNod(tree.root, 63);    tree.root = tree.insertNod(tree.root, 68);    tree.root = tree.insertNod(tree.root, 94);    tree.root = tree.insertNod(tree.root, 44);    tree.root = tree.insertNod(tree.root, 87);    tree.root = tree.insertNod(tree.root, 84);    tree.printTree(tree.root, "", true);    tree.root = tree.deleteNod(tree.root, 96);    tree.root = tree.deleteNod(tree.root, 68);    tree.root = tree.deleteNod(tree.root, 44);    tree.root = tree.deleteNod(tree.root, 87);    tree.root = tree.deleteNod(tree.root, 84);    tree.root = tree.deleteNod(tree.root, 22);    System.out.println("\nAVL tree(after deletion): ");    tree.printTree(tree.root, "", true);  }  Nod root;  int hei(Nod N) {    if (N == null)      return 0;    return N.hei;  }  int max(int a, int b) {    return (a > b) ? a : b;  }  Nod riRotate(Nod y) {    Nod x = y.lef;    Nod T2 = x.ri;    x.ri = y;    y.lef = T2;    y.hei = max(hei(y.lef), hei(y.ri)) + 1;    x.hei = max(hei(x.lef), hei(x.ri)) + 1;    return x;  }  Nod lefRotate(Nod x) {    Nod y = x.ri;    Nod T2 = y.lef;    y.lef = x;    x.ri = T2;    x.hei = max(hei(x.lef), hei(x.ri)) + 1;    y.hei = max(hei(y.lef), hei(y.ri)) + 1;    return y;  }  int getBalanceFactor(Nod N) {    if (N == null)      return 0;    return hei(N.lef) - hei(N.ri);  }  Nod insertNod(Nod node, int item) {    if (node == null)      return (new Nod(item));    if (item < node.item)      node.lef = insertNod(node.lef, item);    else if (item > node.item)      node.ri = insertNod(node.ri, item);    else      return node;    node.hei = 1 + max(hei(node.lef), hei(node.ri));    int balanceFactor = getBalanceFactor(node);    if (balanceFactor > 1) {      if (item < node.lef.item) {        return riRotate(node);      } else if (item > node.lef.item) {        node.lef = lefRotate(node.lef);        return riRotate(node);      }    }    if (balanceFactor < -1) {      if (item > node.ri.item) {        return lefRotate(node);      } else if (item < node.ri.item) {        node.ri = riRotate(node.ri);        return lefRotate(node);      }    }    return node;  }  Nod nodeWithMimumValue(Nod node) {    Nod current = node;    while (current.lef != null)      current = current.lef;    return current;  }  Nod deleteNod(Nod root, int item) {    if (root == null)      return root;    if (item < root.item)      root.lef = deleteNod(root.lef, item);    else if (item > root.item)      root.ri = deleteNod(root.ri, item);    else {      if ((root.lef == null) || (root.ri == null)) {        Nod temp = null;        if (temp == root.lef)          temp = root.ri;        else          temp = root.lef;        if (temp == null) {          temp = root;          root = null;        } else          root = temp;      } else {        Nod temp = nodeWithMimumValue(root.ri);        root.item = temp.item;        root.ri = deleteNod(root.ri, temp.item);      }    }    if (root == null)      return root;    root.hei = max(hei(root.lef), hei(root.ri)) + 1;    int balanceFactor = getBalanceFactor(root);    if (balanceFactor > 1) {      if (getBalanceFactor(root.lef) >= 0) {        return riRotate(root);      } else {        root.lef = lefRotate(root.lef);        return riRotate(root);      }    }    if (balanceFactor < -1) {      if (getBalanceFactor(root.ri) <= 0) {        return lefRotate(root);      } else {        root.ri = riRotate(root.ri);        return lefRotate(root);      }    }    return root;  }  void preOrder(Nod node) {    if (node != null) {      System.out.print(node.item + " ");      preOrder(node.lef);      preOrder(node.ri);    }  }  private void printTree(Nod currPtr, String indent, boolean last) {    if (currPtr != null) {      System.out.print(indent);      if (last) {        System.out.print("Right----");        indent += "   ";      } else {        System.out.print("Left----");        indent += "*  ";      }      System.out.println(currPtr.item);      printTree(currPtr.lef, indent, false);      printTree(currPtr.ri, indent, true);    }  }}