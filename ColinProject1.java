import static java.lang.System.out;import java.util.Vector;import java.util.Scanner;import java.io.IOException;class ColinProject1 {	private long key;		public long getKey() {    return key;    }	   public void setKey(long key) {    this.key = key;   }	   public ColinProject1(long keyval) {    this.key = keyval;    }   	public String displayItem() {    return ("[" + getKey() + "]");    }}class Node {	private static final int max_ch = 4;	private static final int max_items_node = max_ch - 1;	private Node parent;	private Node childArray[] = new Node[max_ch];	private NodeData itemArray[] = new NodeData[max_items_node];	private int numItems;	public int getNum() {    return numItems;    }   	public void increaseItemNum() {    numItems++;    }   	public void decreaseItemNum() {    numItems--;    }   	public Node getChild(int childNum) {    return childArray[childNum];    }   	public void setChild(int childNum, Node child) {    childArray[childNum] = child;    }   	public NodeData getItem(int index) {    return itemArray[index];    }   	public void setItem(int index, NodeData item) {    itemArray[index] = item;    }   	public boolean isItemNull(int index) {    return (itemArray[index] == null) ? true : false;    }   	public Node getParent() {    return parent;    }   	public boolean isLeaf() {    return (getChild(0) == null) ? true : false;    }   	public boolean isFull() {    return (getNum() == max_items_node) ? true : false;    }		public void connectChild(int childNum, Node child) {		setChild(childNum, child);		if(child != null) child.parent = this;	}	public Node disconnectChild(int childNum) {		Node tempNode = getChild(childNum);		setChild(childNum, null);		return tempNode;	}   	public int findItem(long key) {		for(int x = 0; x < max_items_node; x++) {			if(isItemNull(x)) break;			else if(getItem(x).getKey() == key) return x;		}		return -1;	}  		public int insertItem(NodeData newItem) {		increaseItemNum();		for(int x = max_items_node - 1; x >= 0; x--) {			if(isItemNull(x)) continue;			else {				if(newItem.getKey() < getItem(x).getKey()) setItem(x + 1, getItem(x));				else {					setItem(x + 1, newItem);					return x + 1;				}			}		}		setItem(0, newItem);		return 0;	}	public NodeData removeItem() {		NodeData temp = getItem(getNum() - 1);		setItem(getNum() - 1, null);		decreaseItemNum();		return temp;	}		public String displayNode() {		String x = new String("");		for(int node = 0; node < getNum(); node++) x = x + getItem(node).displayItem();				return x;	}}class Tree234 {	private Node root;	   public Node getRoot() {    return root;    }   	public void setRoot(Node root) {    this.root = root;    }		public Tree234() {    this.root = new Node();    }		public int find(long key) {		Node curNode = getRoot();		int childNumber;		while(true) {			if((childNumber = curNode.findItem(key)) != -1) return childNumber;			else if(curNode.isLeaf()) return -1;					else curNode = getNextChild(curNode, key);		}	}	public void insert(long dValue) {		Node curNode = getRoot();		NodeData tempItem = new NodeData(dValue);		while(true) {			if(curNode.isFull()) {				split(curNode);				curNode = curNode.getParent();				curNode = getNextChild(curNode, dValue);            		}            		else if(curNode.isLeaf()) break;            		else curNode = getNextChild(curNode, dValue);        	}		curNode.insertItem(tempItem);	}  	public void split(Node oldNodeForSplit) {		NodeData bItem;		NodeData cItem;		Node parent;		Node child2;		Node child3;		int itemIndex;		cItem = oldNodeForSplit.removeItem();		bItem = oldNodeForSplit.removeItem();		child2 = oldNodeForSplit.disconnectChild(2);		child3 = oldNodeForSplit.disconnectChild(3);		Node newNodeForSplit = new Node();		if(oldNodeForSplit == getRoot()) {			setRoot(new Node());			parent = getRoot();			root.connectChild(0, oldNodeForSplit);		}		else parent = oldNodeForSplit.getParent();				itemIndex = parent.insertItem(bItem);				for(int itemN = parent.getNum() - 1; itemN > itemIndex; itemN--) {			Node temp = parent.disconnectChild(itemN);			parent.connectChild(itemN + 1, temp);		}		parent.connectChild(itemIndex + 1, newNodeForSplit);		newNodeForSplit.insertItem(cItem);		newNodeForSplit.connectChild(0, child2);		newNodeForSplit.connectChild(1, child3);	}   	public Node getNextChild(Node theNode, long theValue) {		int k;		for(k = 0; k < theNode.getNum(); k++)			if(theValue < theNode.getItem(k).getKey()) return theNode.getChild(k);		return theNode.getChild(k);	}	   	public void printTree() {		Vector<String> treeV = new Vector<String>();				treeInfoForPrinting(getRoot(), 0, 0, treeV);				for(int x = 0; x < treeV.size(); x++) out.println("Level " + x + ": " + treeV.get(x));	}	private void treeInfoForPrinting(Node thisNode, int level, int childN, Vector<String> treeV) {		try { treeV.set(level, treeV.get(level) + ", Child" + childN + " = " + thisNode.displayNode()); }		catch(Exception e) { treeV.insertElementAt("Child" + childN + " = " + thisNode.displayNode(), level); }      		for(int x = 0; x < thisNode.getNum() + 1; x++) {       			Node nextNode = thisNode.getChild(x);         		if(nextNode != null) treeInfoForPrinting(nextNode, level + 1, x, treeV);         		         		else return;		}	}   	public Node delete(Node currnode, int theValue) {		Node y = null;				if (currnode.isLeaf()) {			if (currnode.getNumItems() > 1) {				currnode.deletenodevalue(theValue);				return currnode;			} else {				y = deleteleaf_cases(currnode, theValue);				return y;			}		} else {			// delete interior nodes			//boolean x = false;					Node n = getNextChild(currnode, theValue);			Node c = getinordernode(n);			NodeData d = c.getItem(0);			int k = d.dData;			delete(c, d.dData);								Node found = find(theValue);			for(int i = 0; i < found.getNumItems();i++){				if(found.getItem(i).dData==theValue){					found.getItem(i).dData=k;				}			}			return found;					}	}	public Node deleteleaf_cases(Node thisNode, int theValue) {		String sibling_side = "l";		Node p = thisNode.getParent();		Node sibling = thisNode.getsibiling(theValue);		if (sibling == null) {			sibling_side = "r";			sibling = p.getChild(1);		}		if (sibling.getNumItems() == 1) {			for (int i = 0; i <= p.getNumItems(); i++) {				if (p.getChild(i) == sibling && sibling_side == "l") {//					System.out.println("Sibling is on left side & Data is "//							+ sibling.getItem(0).dData);					thisNode.setItem(thisNode.getNumItems() - 1, null);					thisNode.setNumItems(thisNode.getNumItems() - 1);					NodeData d = p.getItem(i);					sibling.insertItem(d);					p.disconnectChild(i + 1);					for (int j = i; j < p.getNumItems(); j++) {						if (j + 1 < p.getNumItems()) {							p.setItem(j, p.getItem(j + 1));							if (j + 2 <= p.getNumItems()) {								p.connectChild(j + 1, p.disconnectChild(j + 2));							}						}					}					p.setItem(p.getNumItems() - 1, null);					p.setNumItems(p.getNumItems() - 1);					// Check if parent is null					if (p.getNumItems() == 0) {//						System.out//								.println("Parent became null; Now Tree is Re-Balancing");						if (p != root) {							p = balancetree(p);						} else {							root = sibling;						}					}					return p;				} else if (p.getChild(i) == sibling && sibling_side == "r") {//					System.out.println("Sibling is on right side & Data is "//							+ sibling.getItem(0).dData);					thisNode.setItem(thisNode.getNumItems() - 1, null);					thisNode.setNumItems(thisNode.getNumItems() - 1);					NodeData d = p.getItem(i - 1);					sibling.insertItem(d);					p.disconnectChild(0);					p.connectChild(0, p.disconnectChild(1));					for (int j = i; j < p.getNumItems(); j++) {						p.setItem(j - 1, p.getItem(j));						if (j + 1 <= p.getNumItems()) {							p.connectChild(j, p.disconnectChild(j + 1));						}					}					p.setItem(p.getNumItems() - 1, null);					p.setNumItems(p.getNumItems() - 1);					// Check if parent is null					if (p.getNumItems() == 0) {//						System.out//								.println("Parent became null; Now Tree is Re-Balancing");						if (p != root) {							p = balancetree(p);						} else {							root = sibling;						}					}					return p;				}			}		} else if (sibling.getNumItems() > 1) {			int f = 0;			if (sibling_side == "r") {				f = 0;			} else {				f = sibling.getNumItems() - 1;			}			for (int i = 0; i <= p.getNumItems(); i++) {				if (p.getChild(i) == sibling && sibling_side == "l") {					thisNode.getItem(0).dData = p.getItem(i).dData;					p.getItem(i).dData = sibling.getItem(f).dData;					sibling.deletenodevalue(sibling.getItem(f).dData);					return p;				}				if (p.getChild(i) == sibling && sibling_side == "r") {					thisNode.getItem(0).dData = p.getItem(i - 1).dData;					p.getItem(i - 1).dData = sibling.getItem(f).dData;					sibling.deletenodevalue(sibling.getItem(f).dData);					return p;				}			}		}		return null;	}	public Node balancetree(Node currnode) { // Argument is empty node.		String sibling_side = "l";		Node p = currnode.getParent();		Node sibling = currnode.getsibiling(-1);		if (sibling == null) {			sibling_side = "r";			sibling = p.getChild(1);		}		if (sibling.getNumItems() == 1) {			for (int i = 0; i <= p.getNumItems(); i++) {				if (p.getChild(i) == sibling && sibling_side == "l") {					// merge parent and child and remove parent//					System.out.println("Sibling is on left side & Data is "//							+ sibling.getItem(0).dData);					NodeData d = p.getItem(i);					sibling.insertItem(d);					// p.connectChild(i, newnode);					sibling.connectChild(sibling.getNumItems(),							currnode.disconnectChild(0));					p.disconnectChild(i + 1);					for (int j = i; j < p.getNumItems(); j++) {						if (j + 1 < p.getNumItems()) {							p.setItem(j, p.getItem(j + 1));							if (j + 2 <= p.getNumItems()) {								p.connectChild(j + 1, p.disconnectChild(j + 2));							}						}					}					p.setItem(p.getNumItems() - 1, null);					p.setNumItems(p.getNumItems() - 1);					// Check if parent is null					if (p.getNumItems() == 0) {//						System.out//								.println("Parent became null; Now Tree is Re-Balancing");						if (p != root) {							p = balancetree(p);						} else {							root = sibling;						}					}					return p;				}				else if (p.getChild(i) == sibling && sibling_side == "r") {//					System.out.println("Sibling is on right side & Data is "//							+ sibling.getItem(0).dData);					NodeData d = p.getItem(i - 1);					sibling.insertatfront(d);					sibling.connectChild(0, currnode.disconnectChild(0));					p.disconnectChild(0);					p.connectChild(0, p.disconnectChild(1));					for (int j = i; j < p.getNumItems(); j++) {						p.setItem(j - 1, p.getItem(j));						if (j + 1 <= p.getNumItems()) {							p.connectChild(j, p.disconnectChild(j + 1));						}					}					p.setItem(p.getNumItems() - 1, null);					p.setNumItems(p.getNumItems() - 1);					// Check if parent is null					if (p.getNumItems() == 0) {//						System.out//								.println("Parent became null; Now Tree is Re-Balancing");						if (p != root) {							p = balancetree(p);						} else {							root = sibling;						}					}					return p;				}			}		} else if (sibling.getNumItems() > 1) {			int f = 0;			if (sibling_side == "r") {				f = 0;			} else {				f = sibling.getNumItems() - 1;			}			for (int i = 0; i <= p.getNumItems(); i++) {				if (p.getChild(i) == sibling && sibling_side == "l") {//					System.out.println("Sibling is on left side & Data is "//							+ sibling.getItem(sibling.getNumItems() - 1).dData);					currnode.setNumItems(currnode.getNumItems()+1);					currnode.connectChild(1, currnode.disconnectChild(0));					currnode.connectChild(0,							sibling.disconnectChild(sibling.getNumItems()));					currnode.setItem(0, p.getItem(i));//					currnode.getItem(0).dData = p.getItem(i).dData;					p.setItem(i, sibling.getItem(f));//					p.getItem(i).dData = sibling.getItem(f).dData;					sibling.setItem(sibling.getNumItems() - 1, null);					sibling.setNumItems(sibling.getNumItems() - 1);					return p;				}				if (p.getChild(i) == sibling && sibling_side == "r") {//					System.out//							.println("Sibling is on right side & Data is ---- "//									+ sibling.getItem(0).dData);					currnode.setNumItems(currnode.getNumItems()+1);					currnode.setItem(0, p.getItem(i - 1));//					System.out.println("Current node value: "//							+ currnode.getItem(0).dData);//					System.out.println("Sibling going to parent: "//							+ sibling.getItem(f).dData);					p.setItem(i - 1, sibling.getItem(f));//					System.out.println("Parent Changed to: "//							+ p.getItem(i - 1).dData);					currnode.connectChild(1, sibling.disconnectChild(f));//					System.out.println("Current node right child value"//							+ currnode.getChild(1).getItem(0).dData);					for (int j = 0; j < sibling.getNumItems(); j++) {						if (j + 1 < sibling.getNumItems()) {							sibling.setItem(j, sibling.getItem(j + 1));						}						sibling.connectChild(j, sibling.disconnectChild(j + 1));					}//					System.out.println("Sibling first value"//							+ sibling.getItem(0).dData);					sibling.setItem(sibling.getNumItems() - 1, null);					sibling.setNumItems(sibling.getNumItems() - 1);					//System.out.println(currnode.getItem(0).dData);					return p;				}			}		}		return null;	}				public Node getinordernode(Node thisNode){		Node c = null;		if(thisNode.isLeaf()){			c = thisNode;		}		else{			c = getinordernode(thisNode.getChild(0));		}		return c;	}}class Tree {		public static void main(String[] args) throws IOException {		boolean cycleController = true;		Tree234 theTree = new Tree234();				while(cycleController) {			switch(getInput("[TtIiDdFfEe]", "\n Press t to Show the tree, I to insert data, D to delete, F to find data & E to exit the program.").charAt(0)) {				case 't': case 'T':				   out.println("\nYour tree contains: ");					theTree.printTree();					break;                             				case 'i': case 'I':					theTree.insert(Integer.parseInt(getInput("[0-9]+", "Value to insert: ")));					break;                      case 'd': case 'D':           theTree.insert(Integer.parseInt(getInput("[0-9]+", "Value to Delete: ")));					break;                    				case 'f': case 'F':					if(theTree.find(Integer.parseInt(getInput("[0-9]+", "Value to find: "))) != -1)						out.println("Value is in the tree");					else						out.println("Value is not in the tree");					break;									case 'e': case 'E':					cycleController = false;					break;									default:					out.print("Wrong\n");			}		}	}	public static String getInput(String filter, String message) throws IOException {		Scanner sc = new Scanner (System.in);		out.println(message);				while (!sc.hasNext(filter)) {			out.println("Select a different choice");			sc.next();		}		return sc.next();	}}